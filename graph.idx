GraphEdge	graph.html#GraphEdge	graph: GraphEdge	
Path	graph.html#Path	graph: Path	
Graph	graph.html#Graph	graph: Graph	
GraphError	graph.html#GraphError	graph: GraphError	
GraphCyclesError	graph.html#GraphCyclesError	graph: GraphCyclesError	
newGraph	graph.html#newGraph,bool	graph: newGraph[Id](isDirected: bool = true): Graph[Id]	
newGraph	graph.html#newGraph,openArray[],bool	graph: newGraph[Id](values: openArray[(Id, Id)]; isDirected: bool = true): Graph[Id]	
default	graph.html#default,typedesc[Graph[Id]]	graph: default[Id](graph: typedesc[Graph[Id]]): Graph[Id]	
contains	graph.html#contains,Graph[Id],Id	graph: contains[Id](graph: Graph[Id]; node: Id): bool	
contains	graph.html#contains,Graph[Id],GraphEdge[Id]	graph: contains[Id](graph: Graph[Id]; edge: GraphEdge[Id]): bool	
getEdge	graph.html#getEdge,Graph[Id],Id,Id	graph: getEdge[Id](graph: Graph[Id]; source, target: Id): GraphEdge[Id]	
edgeCount	graph.html#edgeCount,Graph[Id]	graph: edgeCount[Id](graph: Graph[Id]): int	
nodeCount	graph.html#nodeCount,Graph[Id]	graph: nodeCount[Id](graph: Graph[Id]): int	
nodes	graph.html#nodes.i,Graph[Id]	graph: nodes[Id](graph: Graph[Id]): Id	
allNodes	graph.html#allNodes,Graph[Id]	graph: allNodes[Id](graph: Graph[Id]): seq[Id]	
edgePairs	graph.html#edgePairs.i,Graph[Id]	graph: edgePairs[Id](graph: Graph[Id]): GraphEdge[Id]	
computeInDegrees	graph.html#computeInDegrees,Graph[Id]	graph: computeInDegrees[Id](graph: Graph[Id]): CountTable[Id]	
inDeg	graph.html#inDeg,Graph[Id],Id	graph: inDeg[Id](graph: Graph[Id]; node: Id): int	
outDeg	graph.html#outDeg,Graph[Id],Id	graph: outDeg[Id](graph: Graph[Id]; node: Id): int	
removeNode	graph.html#removeNode,Graph[Id],Id	graph: removeNode[Id](graph: var Graph[Id]; node: Id)	
removeEdge	graph.html#removeEdge,Graph[Id],GraphEdge[Id]	graph: removeEdge[Id](graph: var Graph[Id]; edge: GraphEdge[Id])	
outEdges	graph.html#outEdges.i,Graph[Id],Id	graph: outEdges[Id](graph: Graph[Id]; source: Id): GraphEdge[Id]	
inEdges	graph.html#inEdges.i,Graph[Id],Id	graph: inEdges[Id](graph: Graph[Id]; target: Id): GraphEdge[Id]	
`$`	graph.html#$,Graph[Id]	graph: `$`[Id](graph: Graph[Id]): string	
depthFirst	graph.html#depthFirst.i,Graph[Id],Id	graph: depthFirst[Id](graph: Graph[Id]; root: Id): tuple[id: Id, depth: int]	
breadthFirst	graph.html#breadthFirst.i,Graph[Id],Id	graph: breadthFirst[Id](graph: Graph[Id]; root: Id): Id	
getNoIncoming	graph.html#getNoIncoming,Graph[Id]	graph: getNoIncoming[Id](graph: Graph[Id]): seq[Id]	
topologicalOrdering	graph.html#topologicalOrdering,Graph[Id],openArray[Id]	graph: topologicalOrdering[Id](graph: Graph[Id]; start: openArray[Id] = []): seq[Id]	
findMaxIt	graph.html#findMaxIt.t,untyped,untyped	graph: findMaxIt(s: untyped; op: untyped): untyped	
findIt	graph.html#findIt.t,typed,untyped	graph: findIt(s: typed; op: untyped): int	
graphEasyRepr	graph.html#graphEasyRepr,Graph[Id],proc(Id)	graph: graphEasyRepr[Id](graph: Graph[Id]; name: proc (id: Id): string): string	
findCycles	graph.html#findCycles,Graph[Id],bool,bool,bool	graph: findCycles[Id](graph: Graph[Id]; ignoreSelf: bool = false;\n               overrideDirected: bool = false; yieldMultiedge: bool = false): seq[\n    Path[Id]]	
mergeCycleSets	graph.html#mergeCycleSets,seq[seq[Id]]	graph: mergeCycleSets[Id](cycles: seq[seq[Id]]): seq[HashSet[Id]]	
connectedComponents	graph.html#connectedComponents,Graph[Id],bool	graph: connectedComponents[Id](graph: Graph[Id]; overrideDirected: bool = false): seq[\n    HashSet[Id]]	
ritems	graph.html#ritems.i,openArray[T]	graph: ritems[T](s: openArray[T]): T	
